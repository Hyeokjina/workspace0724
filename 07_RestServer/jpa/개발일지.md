# 개발 일지

## 2025-12-12 - BaseTimeEntity 리팩토링

### 문제 상황
처음에는 Member 엔티티에 createTime과 updateTime을 직접 작성했다.

```java
@Entity
public class Member {
    @Id
    private Long id;

    private String name;
    private String email;

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createTime;

    @LastModifiedDate
    private LocalDateTime updateTime;
}
```

그런데 Board, Comment, Tag 등 다른 엔티티를 추가하면서 문제가 발생했다.
**모든 엔티티마다 똑같은 시간 관리 코드를 복사-붙여넣기** 해야 했다.

### 해결 방법
공통 필드를 관리하는 `BaseTimeEntity` 추상 클래스를 만들어 분리했다.

```java
@Getter
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
public abstract class BaseTimeEntity {

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createTime;

    @LastModifiedDate
    private LocalDateTime updateTime;
}
```

그리고 각 엔티티에서 상속받도록 수정했다.

```java
@Entity
public class Member extends BaseTimeEntity {
    @Id
    private Long id;

    private String name;
    private String email;
    // createTime, updateTime은 자동으로 상속됨!
}
```

### 결과
**재사용성이 정말 좋았다!**

1. **코드량 감소**: 각 엔티티마다 8줄씩 중복되던 코드가 사라졌다.
2. **일관성 보장**: 모든 엔티티의 시간 관리 방식이 동일하게 유지된다.
3. **유지보수 용이**: 시간 관련 로직을 변경할 때 BaseTimeEntity 하나만 수정하면 끝!
4. **확장성**: 새로운 엔티티를 추가할 때 `extends BaseTimeEntity`만 붙이면 자동으로 시간 관리 기능이 추가된다.

특히 Board, Comment, Tag를 추가할 때 시간 필드를 신경 쓸 필요가 없어서 개발 속도가 훨씬 빨라졌다.

### 배운 점
- **DRY(Don't Repeat Yourself) 원칙**의 중요성을 체감했다.
- 처음부터 완벽한 설계를 하지 못해도 괜찮다. 중복이 보이면 그때 리팩토링하면 된다.
- JPA의 `@MappedSuperclass`는 공통 필드를 관리하는 데 아주 유용한 도구다.
- 관심사의 분리(비즈니스 로직 vs 기술적 관심사)를 실천하니 코드가 훨씬 깔끔해졌다.

앞으로도 반복되는 패턴을 발견하면 적극적으로 추상화해야겠다!
